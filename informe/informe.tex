\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{pdfpages}
\usepackage{geometry}

\geometry{
    a4paper,
    margin=1.2in
}

\title{Sistemas Operativos (75.08): Lab Kernel}
\author{
    \\\\\\\\
    Lavandeira, Lucas (\texttt{\#98042})\\\texttt{lucaslavandeira@gmail.com}\\
    \\
    Rozanec, Matias (\texttt{\#97404})\\\texttt{rozanecm@gmail.com}\\
    \\\\\\\\\\\\\\
}
\date{22.jun.2018}

\begin{document}
\maketitle
\newpage

\tableofcontents
\newpage

% *** CONSIGNA ***

% *** RESOLUCION ***
% Some settings for coding style
\lstset{
    basicstyle=\linespread{0.9}\ttfamily\scriptsize,
    frame=single,
    frameround=tttt,
    numbers=left,
    numberstyle=\tiny,
    linewidth=13cm,
    literate=
      {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
      {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
      {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
      {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
      {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
      {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
      {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
      {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
      {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
      {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
      {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
      {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
      {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\part{Resolución}
\section{Creación de stacks en el kernel}

\subsection{Ej: kern2-stack}
\textit{Explicar: ¿qué significa “estar alineado”?}\\
Una variable o array de variables está alineada en memoria a X bits cuando su posición inicial es un múltiplo de X. Por ejemplo estar alineado a 4 bytes significa que su dirección de memoria es un múltiplo de 4 (0, 4, 8, ...). Esto por lo general se hace para tomar ventaja de como el hardware maneja posiciones de memoria (la lectura de posiciones alineadas al tamaño de la palabra de la arquitectura suele ser más eficiente). 
                                                                                
Alinear una variable por lo general significa agregar suficientes bytes con valor nulo hasta que quede la posición incial de la misma en donde la queramos. \\

\textit{Mostrar la sintaxis de C/GCC para alinear a 32 bits el arreglo kstack anterior.}\\
GCC provee el \textbf{atributo} \texttt{aligned} para especificar a cuantos bytes (no bits) se quiere alinear alguna variable. Para alinear \texttt{kstack} a 32 bits, se declararía de la siguiente manera:
                                                                                
\texttt{unsigned char \_\_attribute\_\_ ((aligned (4))) kstack[8192];}\\

\textit{¿A qué valor se está inicializando kstack? ¿Varía entre la versión C y la versión ASM? (Leer la documentación de as sobre la directiva .space.)}\\
Según la directiva \texttt{.space} de x86, \texttt{.space 8192} toma los próximos 8192 bytes y los inicializa a cero. Declarar el arreglo en C de la manera que lo hicimos no inicializa los contenidos, y deja basura en el stack. Esto es aceptable puesto que el stack se lee solo a través del stack pointer que siempre apunta a la dirección con el último valor escrito.

\textit{Explicar la diferencia entre las directivas .align y .p2align de as, y mostrar cómo alinear el stack del kernel a 4 KiB usando cada una de ellas.}












%\lstinputlisting{../Part01/rm0.c}

\newpage

\section{Parte 2}

\newpage

\section{Parte 3}
\end{document}
